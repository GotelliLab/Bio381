---
title: "Lecture #10: Data curation"
author: "Nicholas J. Gotelli"
date: "March 4, 2021"
output: 
  html_document: 
    highlight: tango
    theme: united
---


### Important Distinctions Between Lists and Matrices

```{r, eval=FALSE}

# create a matrix and data frame with same structures
z_mat <- matrix(data=1:30,ncol=3,byrow=TRUE)
z_dframe <- as.data.frame(z_mat) # coerce it

str(z_mat)    # an atomic vector with 2 dimensions
str(z_dframe) # note horizontal layout of variabes!

head(z_dframe) # note automatic variable names
head(z_mat) # note identical layout
colnames(z_mat) <- c("V1","V2","V3") # add col names
head(z_mat)

# element referencing is the same in both
z_mat[3,3]
z_dframe[3,3]

# so is row referencing
z_mat[3,]
z_dframe[3,]

# using column numbers, referencing is also the same
z_mat[,3]
z_dframe[,3]

# one variation for using names
z_mat[,"V3"]
z_dframe[,"V3"]
z_dframe$V3 # note use of $ and named variable column

# what happens if we reference only one dimension?
z_mat[3] # takes the third element of atomic vector (column fill)
z_dframe[3] # takes third atomic vector (= column) from list
```

### Eliminating missing values
```{r, eval=FALSE}
# use complete.cases with atomic vector
print(zD)

complete.cases(zD)

zD[complete.cases(zD)] # clean them out

which(!complete.cases(zD)) # find NA slots

# use with a matrix

m <- matrix(1:20,nrow=5)
m[1,1] <- NA
m[5,4] <- NA
print(m)

m[complete.cases(m),] 

# now get complete cases for only certain columns!
m[complete.cases(m[,c(1,2)]),] # drops row 1
m[complete.cases(m[,c(2,3)]),] # no drops
m[complete.cases(m[,c(3,4)]),] # drops row 4
m[complete.cases(m[,c(1,4)]),] # drops 1&4

```



### Techniques for assignments and subsetting matrices and data frames
```{r,eval=FALSE}
# same principle applied to both dimensions of a matrix
m <- matrix(data=1:12,nrow=3)
dimnames(m) <- list(paste("Species",LETTERS[1:nrow(m)],sep=""),paste("Site",1:ncol(m),sep=""))
print(m)

# subsetting based on elements
m[1:2,3:4]
# same subsetting based on character strings (but no negative elements)
m[c("SpeciesA","SpeciesB"), c("Site3","Site4")]

# use blanks before or after comma to indicate full rows or columns
m[1:2, ]    

m[ ,3:4]

# use logicals for more complex subsetting

# e.g. select all columns for which the totals are > 15

# first try this logical
colSums(m) > 15
m[ , colSums(m) > 15]


# e.g. select all rows for which the row total is 22
m[rowSums(m)==22, ]

# note == for logical equal and != for logical NOT equal
m[rowSums(m)!=22, ]

# e.g., choose all rows for which numbers for site 1 are less than 3
# AND choose all columns for which the numbers for species A are less than 5

# first, try out this logical for rows
m[ ,"Site1"]<3

# add this in and select with all columns
m[m[ ,"Site1"]<3, ]

# and try this logical for columns
m["SpeciesA", ]<5

# add this in and select with all rows
m[ ,m["SpeciesA", ]<5]

# now combine both
m[m[ ,"Site1"]<3,m["SpeciesA", ]<5]

# and compare with full m
print(m)


# caution! simple subscripting to a vector changes the data type!
z <- m[1, ]
print(z)
str(z)

# to keep this as a matrix, must add the drop=FALSE option

z2 <- m[1, ,drop=FALSE]
print(z2)
str(z2)

# caution #2, always use both dimensions, or you will select a single matrix element

m2 <- matrix(data=runif(9),nrow=3)
print(m2)
m2[2, ]

# but now this will just pull the second element
m2[2]

# probably should specify row and column indicators
m2[2,1]
# also use logicals for assignments, not just subsetting
m2[m2>0.6] <- NA
print(m2)


# A few changes for working with data frames:

data <-read.csv(file="antcountydata.csv",header=TRUE,sep=",",stringsAsFactors=FALSE)
str(data)

# the data frame is a list of vectors, so it is set up like a matrix
data[3,2]

# you can specify just the column names

dataNames <- data[c("state","county")]
str(dataNames)

# or in matrix style
dataNames <- data[ ,c("county", "ecoregion")]
str(dataNames)


# as before, with matrices, selecting only a single column changes it
# from a data frame to a vector
dataNames <- data[ ,"county"]
str(dataNames)

```

## Data curation
* GitHub repository   
* Student contract   
* Metadata   
* [Metadata template](https://gotellilab.github.io/Bio381/Scripts/Feb02/ExcelDataTemplate.xlsx)   
* Example of Lauren's data 

## Exporting and importing data

First create a tiny data set in Excel:
```
# comments at the top
# beaucoup metadata
ID, Treatment, Biomass, Notes
1, Control, 30.3, 
2, HighN, 13.0, 
3, HighN, NA, broken scale
4, Control, 35.3,
```
- Save as .csv
- Inspect in RStudio Editor

### Use `read.table` to bring in data
```{r, eval=FALSE}
my_data <- read.table(file="path/to/data.csv",
                    header=TRUE,
                    sep=",",
                    comment.char="#")

# inspect object
str(my_data)

# now add a column
my_data$newVar <- runif(4)
head(my_data)
```

### Use `write.table` to export to a data file

```{r, eval=FALSE}

write.table(x=my_data,
            file="Path/To/OutputFileName.csv",
            HEADER=TRUE,
            sep=",")
```



But this is not a good way to save or share data objects if we are working in R. Some researchers use the `save()` function, which preserves the whole environment, but once it is restored with `load()`, the variable names cannot be changed. It is better to use `saveRDS().

### `saveRDS()`: useful when you are working only in R
```{r, eval=FALSE}
saveRDS(my_data, file="Path/To/FileName.RDS") # .RDS suffix is not required, but good for clarity
```

This only saves a single R object as a binary, but remember, you can bundle up many things into a single list!

Use `readRDS()` to restore it.

### `readRDS()`
```{r, eval=FALSE}
data_in <-readRDS("FileName.RDS") 
```

